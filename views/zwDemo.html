{% extends "base.html" %} {% block main %}
<style>
  body {
    background:#777;
    padding:0;
    margin:0;
    overflow:hidden;
  }
  .control-box {
      width: 100vw;

      justify-content: flex-end;
  }
</style>
<section class="relative" id="vue-box">
    <div class="absolute">
        <div class="control-box display-flex">
            <div class="tl control-group">
                <a class="import-img-btn main-btn-b" @click="changeTextrue()">更换纹理图片（印刷图）</a>
            </div>
        </div>
    </div>
</section>
<section id="designer-box"></section>
<script src="/static/js/OrbitControls.js"></script>
<script src="/static/js/OBJLoader.js"></script>
<script src="/static/js/three_OBJExporter.js"></script>
<script src="/static/js/vue.min.js"></script>
<script>
    $(function () {
        // WebGL能力检测
        if ( ! Detector.webgl ) {
            Detector.addGetWebGLMessage();
        }
        //定义3D世界变量
        var camera;
        var scene;
        var renderer;
        var stats;
        var WIDTH = window.innerWidth;
        var HEIGHT = window.innerHeight;
        var windowHalfX = window.innerWidth / 2;
        var windowHalfY = window.innerHeight / 2;
        var container;
        var mouseX = 0, mouseY = 0;

        // Mesh对象
        var meshObj;
        // model纹理载入器
        var textureLoader;
        // model纹理
        var texture;

        // 初始纹理图路径
        var imgUrls = [
            '/static/images/texture.jpg',
            'static/images/tree.png',
            'static/images/tree-overflow.png'
        ];

        // 观察距离（待研究）
        var viewPosition = -1300;

        init();
        animate();

        // 交互控制
        var vm = new Vue({
            el: '#vue-box',
            data: {
                imgIndex: 0
            },
            methods: {
                changeTextrue() {
                    this.imgIndex = this.imgIndex === 2 ? 0 : this.imgIndex + 1;
                    changeTextrueImg(meshObj);
                }
            }
        });

        function init(){
            // 模型辅助线
            var axisHelper;

            // 定义光源变量
            // 环境光
            var ambientLight;
            // 点光源
            var pointLight;

            // 数据载入器
            var manager;

            // 定义model变量
            // model载入器
            var loader;
            // model载入监控变量
            var onProgress;
            var onError

            // 定义纹理变量
            // 背景纹理载入器
            var cubeTextureLoader;
            // 背景纹理
            var cubeTexture;
            


            // 控件变量
            var controls; // OrbitControls插件

            // 容器变量
            var container = document.getElementById( 'designer-box' );

            camera = new THREE.PerspectiveCamera( 45, WIDTH / HEIGHT, 0.1, 10000 );
            camera.position.z = 1000;

            scene = new THREE.Scene();
            //给场景添加天空盒子纹理
            cubeTextureLoader = new THREE.CubeTextureLoader();
            cubeTextureLoader.setPath( '/static/images/textures/' );
            //六张图片分别是朝前的（posz）、朝后的（negz）、朝上的（posy）、朝下的（negy）、朝右的（posx）和朝左的（negx）。
            cubeTexture = cubeTextureLoader.load( [
                'right.jpg', 'left.jpg',
                'top.jpg', 'bottom.jpg',
                'front.jpg', 'back.jpg'
            ] );
            scene.background = cubeTexture;

            //光源1为环境光
            ambientLight = new THREE.AmbientLight( 0xffffff, 0.8 );
            scene.add( ambientLight );
            //光源2为点光源
            pointLight = new THREE.PointLight( 0xffffff, 0.3 );
            pointLight.position.set( 100, -100, 300);
            scene.add( pointLight );
            scene.add( camera );

            //模型辅助线
            // THREE.AxisHelper has been renamed to THREE.AxesHelper.
            // axisHelper = new THREE.AxisHelper(500);
            axisHelper = new THREE.AxesHelper(500);
            scene.add(axisHelper);

            //引入OrbitControls插件，控制camera
            controls = new THREE.OrbitControls( camera );

            // texture载入
            manager = new THREE.LoadingManager();
            manager.onProgress = function ( url, loaded, total ) {
                console.log(url, loaded, total);
            };
            textureLoader = new THREE.TextureLoader( manager );
            texture = [];
            texture.push(textureLoader.load( imgUrls[0] ));

            // model载入过程监控
            onProgress = function ( xhr ) {
                if ( xhr.lengthComputable ) {
                    var percentComplete = xhr.loaded / xhr.total * 100;
                    console.log( Math.round(percentComplete, 2) + '% downloaded' );
                }
            };
            // model载入失败监控
            onError = function ( xhr ) {
                console.log('model:' + xhr + '引入失败');
            };
            loader = new THREE.JSONLoader( manager );
            loader.load( '/static/models/textureObj2.js', function ( geometry, materials ) {
                meshObj = new THREE.Mesh( geometry, materials );
                meshObj.traverse( function ( child ) {
                    if ( child instanceof THREE.Mesh ) {
                        // 设置纹理映射
                        child.material[0].map = texture[0];
                    }
                });
                meshObj.position.y = viewPosition;
                scene.add( meshObj );
            }, onProgress, onError );

            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            container.appendChild( renderer.domElement );

            stats = new Stats();
            container.appendChild( stats.dom );

            window.addEventListener( 'resize', onWindowResize, false );
        }
        function onWindowResize() {
            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );
        }
        function animate() {

            requestAnimationFrame( animate );

            render();
            stats.update();
        }

        function render() {
            renderer.render( scene, camera );
        }

        function changeTextrueImg(meshObj) {
            var start = new Date();
            var newTexture;

            composeImgs(function (img) {
                newTexture  = textureLoader.load( img );
                meshObj.traverse( function ( child ) {
                if ( child instanceof THREE.Mesh ) {
                    // 设置纹理映射
                    composeImgs(function (img) {
                        child.material[0].map = newTexture;
                    });
                    // child.material[0].map = texture[vm.imgIndex];
                    }
                });
                render();
                var end = new Date();
                console.log(end - start);
            });

            // if (!texture[vm.imgIndex]) {
            //     texture.push( textureLoader.load( imgUrls[vm.imgIndex] ) );
            // }
            // if (vm.imgIndex !== 0) {
            //     texture[vm.imgIndex].wrapS = THREE.MirroredRepeatWrapping;
            //     texture[vm.imgIndex].wrapT = THREE.MirroredRepeatWrapping;
            //     texture[vm.imgIndex].repeat.set( 1, 1 );
            //     texture[vm.imgIndex].needsUpdate = true;
            // }
        }
        // 图片合成
        function composeImgs( finishCallBack, imgUrl, baseUrl ){
            var canvas = document.createElement( "canvas" );
            var context = canvas.getContext( '2d' );
            var manager = new THREE.LoadingManager( undefined, onProgress, onError );
            var loader = new THREE.ImageLoader( manager );
            var imgS = [];
            // 纹理图大小
            var backgroundWidth = 2048;
            var backgroundHeight = 2048;
            // 设计图大小
            var imgWidth = 420;
            var imgHeigth = 600;
            // 偏移量
            var leftSpace = 180;
            var topSpace = 1300;
            var imgUrls = [
                '/static/images/texture.jpg',
                'static/images/tree.png',
                'static/images/tree-overflow.png'
            ];
            // 获取图片地址
            baseUrl = baseUrl || imgUrls[0];
            imgUrl = imgUrl || imgUrls[1];

            // 图片全部载入后，合成图片
            manager.onLoad = function () {
                [].forEach.call(imgS, function ( ele, i ) {
                    if( i === 0 ) {
                        context.drawImage( ele, 0, 0 );
                    } else {
                        context.drawImage( ele, 0, 0, imgWidth, imgHeigth, leftSpace, topSpace, imgWidth, imgHeigth );
                    }
                });
                finishCallBack( canvas.toDataURL( 'img/png' ) );
                imgS.splice(1);
            }

            loader.load( baseUrl, function ( img ) {
                onLoad( img );
                loader.load( imgUrl, onLoad );
            } );
            
            canvas.width = backgroundWidth;
            canvas.height = backgroundHeight;
            canvas.style.width = "2048px";
            canvas.style.height = "2048px";

            function onLoad( img ) {
                imgS.push( img );
            };
            function onProgress( url, loaded, total ) {
                console.log(url, loaded, total);
            };
            function onError( xhr ) {
                console.log('model:' + xhr + '引入失败');
            };
        }
    });
</script>
{% endblock %}